{"version":3,"file":"customEws.js","mappings":"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","sources":["webpack:///./src/taskpane/easyEws.js?"],"sourcesContent":["/*!\n * easyEWS JavaScript Library v1.0.20\n * http://theofficecontext.com\n *\n * Copyright David E. Craig and other contributors\n * Portions Copyright (c) 2020 Vijay Samtani\n * Released under the MIT license\n * https://tldrlegal.com/license/mit-license\n *\n * Date: 2020-08-27T15:44EST\n */\n /**\n * The global easyEws object \n * @type {__nonInstanceEasyEwsClass} \n * */\nvar easyEws =  new __nonInstanceEasyEwsClass();\n/**\n * @class\n */\nfunction __nonInstanceEasyEwsClass() {\n\n    /** @type {string[]} */\n    var groups = [];\n    /** @type {string[]} */\n    var processedGroups = []; \n    /** @type {MailBoxUser[]} */\n    var users = [];\n    /** @type {successCallbackMailboxUserArray} */\n    var splitGroupSuccessCallback;\n    /** @type {errorCallback} */\n    var splitGroupErrorCallback;\n    /** @type {debugCallback} */\n    var splitGroupDebugCallback;\n    /** @type {number} */\n    var groupCount = 0;\n\n/***********************************************************************************************\n ***********************************************************************************************\n ***********************************************************************************************\n                                ****  *   * ****  *     *****  ***                                  \n                                *   * *   * *   * *       *   *   *                                 \n                                ****  *   * ****  *       *   *                                     \n                                *     *   * *   * *       *   *   *                                 \n                                *      ***  ****  ***** *****  ***                                  \n***********************************************************************************************\n***********************************************************************************************\n***********************************************************************************************/\n    /**\n     * This function finds the Parent message of a reply/forward by using the InReplyTo\n     * field to find the InternetMessageId of the parent.\n     * @param {string} childId The id of the item whose parent if you want to find\n     * @param {successCallback} successCallback Returns a string with the parent id or null if there is no parent found\n     * @param {errorCallback} errorCallback Error handler callback - function(Error) { }\n     * @param {debugCallback} debugCallback Debug handler returns raw XML - function(String) { }\n     */\n    this.getParentId = function (childId, successCallback, errorCallback, debugCallback) {\n        /** @type {string} */\n        var soap =\n            '<m:GetItem>' +\n            '    <m:ItemShape>' +\n            '        <t:BaseShape>AllProperties</t:BaseShape>' +\n            '    </m:ItemShape>' +\n            '    <m:ItemIds>' +\n            '        <t:ItemId Id=\"' + childId + '\"/>' +\n            '    </m:ItemIds>' +\n            '</m:GetItem>';\n        soap = getSoapHeader(soap);\n        // make the EWS call\n        asyncEws(soap, function (getItemXmlDoc) {\n        /**@type {string} */\n            var internetMessageId = \"\";\n            try {\n                internetMessageId = getNodes(getItemXmlDoc, \"t:InReplyTo\")[0].textContent;\n            } catch(error) {\n                // returns null if there is no InReplyTo field which likely means\n                // that this item is not a reply or forward but a new item\n                successCallback(null);\n                return;\n            }\n            // fix the message id so it will not error\n            internetMessageId = internetMessageId.replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\");\n            soap =\n                '<m:FindItem Traversal=\"Shallow\">' +\n                '\t<m:ItemShape>' +\n                '\t\t<t:BaseShape>IdOnly</t:BaseShape>' +\n                '\t</m:ItemShape>' +\n                '\t<m:IndexedPageItemView MaxEntriesReturned=\"50\" Offset=\"0\" BasePoint=\"Beginning\" />' +\n                '\t<m:Restriction>' +\n                '\t\t<t:Contains ContainmentMode=\"Substring\" ContainmentComparison=\"IgnoreCase\">' +\n                '\t\t\t<t:FieldURI FieldURI=\"message:InternetMessageId\" />' +\n                '\t\t\t<t:Constant Value=\"' + internetMessageId + '\" />' +\n                '\t\t</t:Contains>' +\n                '\t</m:Restriction>' +\n                '\t<m:ParentFolderIds>' +\n                '\t\t<t:DistinguishedFolderId Id=\"inbox\" />' +\n                '\t</m:ParentFolderIds>' +\n                '</m:FindItem>';\n            soap = getSoapHeader(soap);\n            asyncEws(soap, function (findItemXmlDoc) {\n                var parentId = getNodes(findItemXmlDoc, \"t:ItemId\")[0].attributes[\"Id\"].value;\n                if (successCallback) successCallback(parentId);\n            }, function (error) {\n                if (errorCallback) errorCallback(error);\n            }, function (debug) {\n                if (debugCallback) debugCallback(debug);\n            });\n        }, function (error) {\n            if (errorCallback) errorCallback(error);\n        }, function (debug) {\n            if (debugCallback) debugCallback(debug);\n        });\n    };\n    /**\n     * This callback type is called 'resolveNamesCallback' and is displayed as a global symbol.\n     *\n     * @callback resolveNamesCallback\n     * @param {ResolveNamesType[]} resolvedNamesArray\n     */\n\n    /**\n     * PUBLIC: Resolves the recipient\n     * SEE: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/resolvenames-operation\n     * \n     * @param {string} recipient - The recipient name\n     * @param {resolveNamesCallback} [successCallback] - returns 'succeeeded' is successful - function(ResolveNamesType) { }\n     * @param {errorCallback} [errorCallback] - Error handler callback - function(Error) { }\n     * @param {debugCallback} [debugCallback] - Debug handler returns raw XML - function(String) { }\n     */\n    this.resolveRecipient = function (recipient, successCallback, errorCallback, debugCallback) {\n        var soap = '<ResolveNames xmlns=\"http://schemas.microsoft.com/exchange/services/2006/messages\" '+\n                                 'xmlns:t=\"http://schemas.microsoft.com/exchange/services/2006/types\" ' +\n                                 'ReturnFullContactData=\"true\">' +\n                        '<UnresolvedEntry>' + recipient + '</UnresolvedEntry>' +\n                    '</ResolveNames>';\n        soap = getSoapHeader(soap);\n        // make the EWS call\n        asyncEws(soap, function (xmlDoc) {\n            if (successCallback) {\n                var message = getNodes(xmlDoc, \"m:MessageText\");\n                if(message != null && message.length > 0 && \n                   message[0].innerHTML == \"No results were found.\") {\n                    successCallback(null);\n                } else {\n                    var returnArray = [];\n                    /**@type {XMLNode[]} */\n                    var nodes = getNodes(xmlDoc,\"t:Mailbox\");\n                    // this returns an array like this:\n                    // <t:Mailbox>\n                    //  <t:Name>David Craig</t:Name>\n                    //  <t:EmailAddress>decyahoo-nope@yahoo.com</t:EmailAddress>\n                    //  <t:RoutingType>SMTP</t:RoutingType>\n                    //  <t:MailboxType>Contact</t:MailboxType>\n                    // </t:Mailbox>\n                    for(var idx = 0; idx < nodes.length; idx++) {\n                        /**@type {XMLNode} */\n                        var value = nodes[idx];\n                        var name = getNodes(value, \"t:Name\")[0].textContent;\n                        var email = getNodes(value, \"t:EmailAddress\")[0].textContent;\n                        var route = getNodes(value, \"t:RoutingType\")[0].textContent;\n                        var box = getNodes(value, \"t:MailboxType\")[0].textContent;\n                        var obj = new ResolveNamesType(name, email, route, box);\n                        returnArray.push(obj);\n                    }\n                    successCallback(returnArray);\n                }\n            }\n        }, function (errorDetails) {\n            if (errorCallback != null)\n                errorCallback(errorDetails);\n        }, function (debug) {\n            if (debugCallback != null)\n                debugCallback(debug);\n        });\n    };\n\n    /**\n     * Class to hold resolved names from the ResolveNames function\n     * @class\n     * @param {string} name \n     * @param {string} emailAddress \n     * @param {string} routingType \n     * @param {string} mailboxType \n     * @property {string} name \n     * @property {string} emailAddress \n     * @property {string} routingType \n     * @property {string} mailboxType \n     */\n    function ResolveNamesType(name, emailAddress, routingType, mailboxType) {\n        this.name = name;\n        this.emailAddress = emailAddress;\n        this.routiingType = routingType;\n        this.mailboxType = mailboxType;\n    }\n\n    /**\n    * PUBLIC: creates and sends a new email message with 1+ recipients, 0+ attachments. Can specify where to save copy.\n    * \n    * @param {SendMailFunctionObject} p - A sendmail object\n    */\n    this.sendMailItem = function(p) {\n        // originally, this was an ES6 initilized parameter, which is not supported in IE11\n        // Fix for issue #12, pull out each parameter and initialize individually\n        // {subject, body, recipients = [\"\"], attachments = [{name: \"\", mime:\"\"}], folderid = \"sentitems\", successCallback, errorCallback, debugCallback}\n        /**@type {string} */\n        var subject = p.subject;\n        /**@type {string} */\n        var bodytype = p.bodytype.toLowerCase() == \"html\" ? \"HTML\" : \"Text\";\n        /**@type {string} */\n        var body = (bodytype == \"HTML\") ? escapeHTML(p.body) : p.body;\n        /**@type {string[]} */\n        var recipients = (p.recipients !== undefined && p.recipients !== null) ? p.recipients : [];\n        /**@type {SimpleAttachmentObject[]} */\n        var attachments = (p.attachments !== undefined && p.attachments !== null) ? p.attachments : [new SimpleAttachmentObject(\"\",\"\")];\n        /**@type {string[]} */\n        var folderid = (p.folderid !== undefined && p.folderid !== null && p.folderid !== \"\") ? p.folderid: \"sentitems\";\n        /**@type {successCallback} */\n        var successCallback = p.successCallback;\n        /**@type {errorCallback} */\n        var errorCallback = p.errorCallback;\n        /**@type {debugCallback} */\n        var debugCallback = p.debugCallback;\n\n        //construct recipients\n        /**@type{string} */\n        var xmlRecipients = \"\";\n        if(recipients === undefined || recipients === null || recipients.length == 0) {\n            errorCallback(\"No recipients defined.\");\n            return;\n        }\n        recipients.forEach( function(address) {\n            xmlRecipients += '<t:Mailbox><t:EmailAddress>' + address + '</t:EmailAddress></t:Mailbox>';\n        });\n        xmlRecipients = '<t:ToRecipients>' + xmlRecipients + '</t:ToRecipients>';\n\n        // construct attachments\n        if(attachments !== undefined && attachments !== null && attachments.length > 0) { \n            /**@type {string} */\n            var xmlAttachments = \"\";\n            attachments.forEach( function (attachment) {\n                // Check if it's an empty object (ie, nothing to attach)   \n                if (attachment.name !== \"\" && attachment.mime !== \"\") {\n                    if(attachment.type == \"item\") {\n                        // add the item as an email/message item\n                        xmlAttachments +=   '<t:ItemAttachment>' +\n                                                '<t:Name>' + attachment.name + '</t:Name>' +\n                                                '<t:IsInline>false</t:IsInline>' +\n                                                '<t:Message>' +\n                                                '<t:MimeContent CharacterSet=\"UTF-8\">' + attachment.mime + '</t:MimeContent>' +\n                                                '</t:Message>' +\n                                            '</t:ItemAttachment>';\n                    } else {\n                        // add the item as a file attachment\n                        xmlAttachments +=   '<t:FileAttachment>' +\n                                                '<t:Name>' + attachment.name + '</t:Name>' +\n                                                '<t:IsInline>false</t:IsInline>' +\n                                                '<t:IsContactPhoto>false</t:IsContactPhoto>' +\n                                                '<t:Content>' + attachment.mime + '</t:Content>' +\n                                            '</t:FileAttachment>';\n                    }\n                };\n            });            \n            if (xmlAttachments !== \"\") xmlAttachments = '<t:Attachments>' + xmlAttachments + '</t:Attachments>';\n        }\n    \n        // construct folder spec to save the sent email in \n        /**@type {string} */\n        var xmlSavedFolder = '<m:SavedItemFolderId><t:DistinguishedFolderId Id=\"' + folderid + '\" /></m:SavedItemFolderId>';\n\n        // assemble the soap request\n        /**@type {string} */\n        var soap = '<m:CreateItem MessageDisposition=\"SendAndSaveCopy\">' +\n                        xmlSavedFolder +\n                    '    <m:Items>' +\n                    '        <t:Message>' +\n                    '            <t:Subject>' + subject + '</t:Subject>' +\n                    '            <t:Body BodyType=\"'+ bodytype + '\">' + body + '</t:Body>' +\n                                    xmlAttachments +\n                                    xmlRecipients +\n                    '        </t:Message>' +\n                    '    </m:Items>' +\n                    '</m:CreateItem>';\n        soap = getSoapHeader(soap);\n \n        // make the EWS call \n        asyncEws(soap, function (xmlDoc) {\n            // Get the required response, and if it's NoError then all has succeeded, so tell the user.\n            // Otherwise, tell them what the problem was. (E.G. Recipient email addresses might have been\n            // entered incorrectly --- try it and see for yourself what happens!!)\n            /** @type {string} */\n            var elem = xmlDoc.getElementsByTagName(\"m:ResponseCode\")[0];\n            if(elem == null) elem = xmlDoc.getElementsByTagName(\"ResponseCode\")[0];\n            /**@type {string} */\n            var result = elem.textContent;\n            if (result == \"NoError\") {\n                successCallback(result);\n            }\n            else {\n                if (errorCallback != null)\n                    errorCallback(result);\n            }\n        }, function (errorDetails) {\n            if (errorCallback != null)\n                  errorCallback(errorDetails);\n        }, function (debug) {\n            if (debugCallback != null)\n                  debugCallback(debug);\n        });\n    };               \n\n\n    /**\n     * PUBLIC: creates a new emails message with a single attachment and sends it\n     * \n     * @param {string} subject - The subject for the message to be sent\n     * @param {string} body - The body of the message to be sent\n     * @param {string} to - The email address of the recipient\n     * @param {string} attachmentName - Name of the attachment\n     * @param {string} attachmentMime - MIME content in Base64 for the attachment\n     * @param {successCallback} successCallback - Callback with 'success' if compelted successfully - function(string) { }\n     * @param {errorCallback} errorCallback - Error handler callback - function(string) { }\n     * @param {debugCallback} debugCallback - Debug handler returns raw XML - function(string) { }\n     */\n    this.sendPlainTextEmailWithAttachment = function (subject, body, to, attachmentName, attachmentMime, successCallback, errorCallback, debugCallback) {\n        /**@type {SimpleAttachmentObject} */\n        var att = new SimpleAttachmentObject(attachmentName, attachmentMime, \"item\");\n        /**@type {SendMailFunctionObject} */\n        var p = new SendMailFunctionObject(subject, body, \"text\", [to], [att], \"sentitems\", \n                                           successCallback, errorCallback, debugCallback);\n        // send it\n        this.sendMailItem(p);\n     };\n    /**\n     * PUBLIC: gets the mail item as raw MIME data\n     * \n     * @param {string} mailItemId - The id for the item\n     * @param {successCallback} successCallback - Callback with email message as MIME Base64 string - function(string) { } \n     * @param {errorCallback} errorCallback - Error handler callback - function(Error) { }\n     * @param {debugCallback} debugCallback - Debug handler returns raw XML - function(String) { }\n     */\n    this.getMailItemMimeContent = function (mailItemId, successCallback, errorCallback, debugCallback) {\n        /** @type {string} */\n        var soap =\n            '<m:GetItem>' +\n            '    <m:ItemShape>' +\n            '        <t:BaseShape>IdOnly</t:BaseShape>' +\n            '        <t:IncludeMimeContent>true</t:IncludeMimeContent>' +\n            '    </m:ItemShape>' +\n            '    <m:ItemIds>' +\n            '        <t:ItemId Id=\"' + mailItemId + '\"/>' +\n            '    </m:ItemIds>' +\n            '</m:GetItem>';\n        soap = getSoapHeader(soap);\n        // make the EWS call \n        asyncEws(soap, function (xmlDoc) {\n            /** @type {array} */\n            var nodes = getNodes(xmlDoc,\"t:MimeContent\");\n            /** @type {string} */\n            var content = nodes[0].textContent;\n            successCallback(content);\n        }, function (errorDetails) {\n            if (errorCallback != null)\n                errorCallback(errorDetails);\n        }, function (debug) {\n            if (debugCallback != null)\n                debugCallback(debug);\n        });\n    };\n    /**\n     * PUBLIC: Updates the headers in the mail item\n     * SEE: https://msdn.microsoft.com/en-us/library/office/dn596091(v=exchg.150).aspx\n     * SEE: https://msdn.microsoft.com/en-us/library/office/dn495610(v=exchg.150).aspx\n     * \n     * @param {string} mailItemId - The id of the item to update\n     * @param {string} headerName - The header item to add/update\n     * @param {string} headerValue - The header value to update\n     * @param {boolean} [isMeeting] - is required to be true for meeting requests\n     * @param {successCallback} [successCallback] - returns 'succeeeded' is successful - function(String) { }\n     * @param {errorCallback} [errorCallback] - Error handler callback - function(Error) { }\n     * @param {debugCallback} [debugCallback] - Debug handler returns raw XML - function(String) { }\n     */\n    this.updateEwsHeader = function (mailItemId, headerName, headerValue, isMeeting,\n                                     successCallback, errorCallback, debugCallback) {\n        /** @type {string} */\n        var firstLine = '<m:UpdateItem MessageDisposition=\"SaveOnly\" ConflictResolution=\"AlwaysOverwrite\">';\n        if(isMeeting){\n            firstLine = '<m:UpdateItem MessageDisposition=\"SaveOnly\" ConflictResolution=\"AlwaysOverwrite\" SendMeetingInvitationsOrCancellations=\"SendOnlyToChanged\">';\n        }\n        /** @type {string} */\n        var soap =\n            firstLine +\n            '   <m:ItemChanges>' +\n            '       <t:ItemChange>' +\n            '           <t:ItemId Id=\"' + mailItemId + '\"/>' +\n            '           <t:Updates>' +\n            '               <t:SetItemField>' +\n            '                   <t:ExtendedFieldURI DistinguishedPropertySetId=\"InternetHeaders\"' +\n            '                                       PropertyName=\"' + headerName + '\"' +\n            '                                       PropertyType=\"String\" />' +\n            '                   <t:Message>' +\n            '                       <t:ExtendedProperty>' +\n            '                           <t:ExtendedFieldURI DistinguishedPropertySetId=\"InternetHeaders\"' +\n            '                                               PropertyName=\"' + headerName + '\"' +\n            '                                               PropertyType=\"String\" />' +\n            '                               <t:Value>' + headerValue + '</t:Value>' +\n            '                           </t:ExtendedProperty>' +\n            '                   </t:Message>' +\n            '               </t:SetItemField>' +\n            '           </t:Updates>' +\n            '       </t:ItemChange>' +\n            '   </m:ItemChanges>' +\n            '</m:UpdateItem>';\n        soap = getSoapHeader(soap);\n        // make the EWS call\n        asyncEws(soap, function (xmlDoc) {\n            if (successCallback)\n                successCallback(\"succeeded\");\n        }, function (errorDetails) {\n            if (errorCallback != null)\n                errorCallback(errorDetails);\n        }, function (debug) {\n            if (debugCallback != null)\n                debugCallback(debug);\n        });\n    };\n    /**\n     * PUBLIC:  Returns a list of items in the folder\n     * \n     * @param {string} folderId - The ID of the folder you want to search\n     * @param {successCallbackArray} successCallback - Callback with array of item IDs - function(String[]) { }\n     * @param {errorCallback} errorCallback - Error handler callback - function(Error) { }\n     * @param {errorCallback} errorCallback - Debug handler returns raw XML - function(String) { }\n     */\n    this.getFolderItemIds = function (folderId, successCallback, errorCallback, debugCallback, opts) {\n        if (opts === null) {\n            opts = {\n              maxEntries: 10,\n              queryString: \"\",\n            };\n        }\n\n        /** @type {string} */\n        var soap =\n            '<m:FindItem Traversal=\"Shallow\">' +\n            '   <m:ItemShape> ' +\n            '       <t:BaseShape>IdOnly</t:BaseShape>' +\n            '   </m:ItemShape>' +\n            '   <m:ParentFolderIds>' +\n            '       <t:FolderId Id=\"' + folderId + '\"/>' +\n            '   </m:ParentFolderIds>' +\n            '   <m:IndexedPageItemView MaxEntriesReturned=\"' +\n                (opts.maxEntries? opts.maxEntries : 10) +\n            '\" Offset=\"0\" BasePoint=\"Beginning\" />' +\n            '   <m:QueryString>' +\n                (opts.queryString? opts.queryString : \"\") +\n            '</m:QueryString>' +\n            '</m:FindItem>';\n\n        /** @type {array} */\n        var returnArray = [];\n\n        soap = getSoapHeader(soap);\n\n        // call ews\n        asyncEws(soap, function (xmlDoc) {\n            /** @type {XMLNode} */\n            var nodes = getNodes(xmlDoc, \"t:ItemId\");\n            // loop through and return an array of ids\n            for(var idx=0;idx<nodes.length;idx++) {\n                returnArray.push(nodes[idx].getAttribute(\"Id\"));\n            }\n            // $.each(nodes, function (index, value) {\n            //     returnArray.push(value.getAttribute(\"Id\"));\n            // });\n            successCallback(returnArray);\n        }, function (errorDetails) {\n            if (errorCallback != null) {\n                errorCallback(errorDetails);\n            }\n        }, function (debug) {\n            if (debugCallback != null)\n                debugCallback(debug);\n        });\n    };\n    /**\n     * PUBLIC:  Gets the item details for a specific item by ID\n     * \n     * @param {string} itemId The ID for the item\n     * @param {successCallbackMailItem} successCallback - Callback with the details of the MailItem - function(MailItem) { }\n     * @param {errorCallback} errorCallback - Error handler callback - function(Error) { }\n     * @param {debugCallback} debugCallback - Debug handler returns raw XML - function(String) { }\n     */\n    this.getMailItem = function (itemId, successCallback, errorCallback, debugCallback) {\n        /** @type {string} */\n        var soap =\n            '<m:GetItem>' +\n            '   <m:ItemShape>' +\n            '       <t:BaseShape>Default</t:BaseShape>' +\n            '       <t:IncludeMimeContent>true</t:IncludeMimeContent>' +\n            '   </m:ItemShape>' +\n            '   <m:ItemIds>' +\n            '       <t:ItemId Id=\"' + itemId + '\" />' +\n            '   </m:ItemIds>' +\n            '</m:GetItem>';\n        soap = getSoapHeader(soap);\n        // make call to EWS\n        asyncEws(soap, function (xmlDoc) {\n            /** @type {MailItem} */\n            var item = new MailItem(xmlDoc);\n            successCallback(item);\n        }, function (errorDetails) {\n            if(errorCallback != null) {\n                errorCallback(errorDetails);\n            }\n        }, function (debug) {\n            if (debugCallback != null)\n                debugCallback(debug);\n        });\n    };\n\n    /**\n     * PUBLIC:      Splits groups and groups in groups, async, until all users are\n     *              found and added to the list. The list of MailBoxUsers[] is\n     *              returned as a paramater of the success callback.\n     * NOTE:        For performance reasons, this will STOP splitting groups after 10\n     *              levels deeps. If groups nesting is greater than this it is bad design\n     *              on the Exchange organization\n     * @param {string[]} groupList The alias for the group(s) to be split\n     * @param {successCallbackMailboxUserArray} sucessCallback Callback with array of MailBoxUsers - function(MailBoxUser[]) { }\n     * @param {errorCallback} errorCallback - Error handler callback - function(Error) { }\n     * @param {debugCallback} debugCallback - Debug handler returns raw XML - function(String) { }\n     */\n    this.splitGroupsAsync = function(groupList, successCallback, errorCallback, debugCallback) {\n        // cleanup - reset arrays\n        groups = [];\n        users = [];\n        processedGroups = [];\n        groupCount = 0;\n        // add the current groups\n        groups.push(groupList);\n        // set callbacks\n        splitGroupSuccessCallback = successCallback;\n        splitGroupErrorCallback = errorCallback;\n        splitGroupDebugCallback = debugCallback;\n        // now start...\n        splitGroupsRecursivelyAsync();\n    };\n\n    /**\n     * PUBLIC:      Expands a group and returns all the members\n     * NOTE:        Does not enumerate groups in groups\n     * \n     * @param {string} group The alias for the group to be expanded\n     * @param {successCallbackMailboxUserArray} successCallback - Callback with array of MailBoxUsers - function(MailBoxUser[]) { }\n     * @param {errorCallback} errorCallback - Error handler callback - function(Error) { }\n     * @param {errorCallback} errorCallback - Debug handler returns raw XML - function(String) { }\n     */\n    this.expandGroup = function (group, successCallback, errorCallback, debugCallback) {\n        // NOTE: Some groups might have an unsafe character like &\n        //       So, here we first make sure there is not a mix first by \n        //       converting already safe to unsafe, then converting everything\n        //       to a safe format.\n        // NOTE: Confirmed in O365 - unable to create groups with &\n        // NOTE: Confirmed in EX2106/2019 - able to create groups with &\n        // Microsoft Offical documentation on the matter:\n        // https://docs.microsoft.com/en-us/office365/troubleshoot/active-directory/email-address-contain-underscore\n        // NOTE: Fixed per issue #8: Expanding groups with '&' ampersand in the group\n        /** @type {string} */\n        var safeGroup = group.replace('&amp;', '&').replace('&', '&amp;'); \n        /** @type {string} */\n        var soap =\n            '<m:ExpandDL>' +\n            '    <m:Mailbox>' +\n            '        <t:EmailAddress>' + safeGroup + '</t:EmailAddress>' +\n            '    </m:Mailbox>' +\n            '</m:ExpandDL>';\n        soap = getSoapHeader(soap);\n        // make the EWS call\n        /** @type {array} */\n        var returnArray = [];\n        asyncEws(soap, function (xmlDoc) {\n            /** @type {array} */\n            var extendedProps = getNodes(xmlDoc, \"t:Mailbox\");\n            // loop through and return an array of properties\n            for(var idx=0; idx<extendedProps.length; idx++) {\n                returnArray.push(new MailboxUser(extendedProps[idx]));\n            }\n            // $.each(extendedProps, function (index, value) {\n            //     returnArray.push(new MailboxUser(value));\n            // });\n            successCallback(returnArray);\n        }, function (errorDetails) {\n            if (errorCallback != null)\n                errorCallback(errorDetails);\n        }, function (debug) {\n            if (debugCallback != null)\n                debugCallback(debug);\n        });\n    };\n    /**\n     *  PUBLIC: Find a given conversation by the ID\n     *  NOTE: Search for parent:\n     *      http://stackoverflow.com/questions/19008696/exchange-find-items-in-ews-conversation-using-xml-request\n     *      http://www.outlookcode.com/codedetail.aspx?id=1714\n     *      https://msdn.microsoft.com/en-us/library/office/dn610351(v=exchg.150).aspx\n     * \n     * @param {string} converstionId - The conversation to find\n     * @param {successCallbackArray} successCallback - Callback with array of item IDs - function(String[]) { }\n     * @param {errorCallback} errorCallback - Error handler callback - function(Error) { }\n     * @param {errorCallback} errorCallback - Debug handler returns raw XML - function(String) { }\n     */\n    this.findConversationItems = function (conversationId, successCallback, errorCallback, debugCallback) {\n        /** @type {string} */\n        var soap =\n            '       <m:GetConversationItems>' +\n            '           <m:ItemShape>' +\n            '               <t:BaseShape>IdOnly</t:BaseShape>' +\n            '               <t:AdditionalProperties>' +\n            '                   <t:FieldURI FieldURI=\"item:Subject\" />' +\n            '                   <t:FieldURI FieldURI=\"item:DateTimeReceived\" />' +\n            '               </t:AdditionalProperties>' +\n            '           </m:ItemShape>' +\n            '           <m:FoldersToIgnore>' +\n            '               <t:DistinguishedFolderId Id=\"deleteditems\" />' +\n            '               <t:DistinguishedFolderId Id=\"drafts\" />' +\n            '           </m:FoldersToIgnore>' +\n            '           <m:SortOrder>TreeOrderDescending</m:SortOrder>' +\n            '           <m:Conversations>' +\n            '               <t:Conversation>' +\n            '                   <t:ConversationId Id=\"' + conversationId + '\" />' +\n            '               </t:Conversation>' +\n            '           </m:Conversations>' +\n            '       </m:GetConversationItems>';\n        soap = getSoapHeader(soap);\n        // Make EWS call\n        asyncEws(soap, function (xmlDoc) {\n            /** @type {array} */\n            var returnArray = [];\n            try {\n                /** @type {array} */\n                var nodes = getNodes(xmlDoc, \"t:ItemId\");\n                if (nodes == null) {\n                    if (errorCallback != null) {\n                        errorCallback(new Error(\"The XML returned from the server could not be parsed.\"));\n                    }\n                } else if (nodes.length == 0) {\n                    successCallback(null);\n                } else {\n                    // loop through and return an array of ids\n                    for(var idx=0; idx < nodes.length; idx++) {\n                        returnArray.push(nodes[idx].getAttribute(\"Id\"));\n                    }\n                    // $.each(nodes, function (index, value) {\n                    //     returnArray.push(value.getAttribute(\"Id\"));\n                    // });\n                    successCallback(returnArray);\n                }\n            } catch (error) {\n                if (errorCallback != null)\n                    errorCallback(error);\n            }\n        }, function (errorDetails) {\n            if (errorCallback != null)\n                errorCallback(errorDetails);\n        }, function (debug) {\n            if (debugCallback != null)\n                debugCallback(debug);\n        });\n    };\n    /**\n     * PUBLIC: Gets a specific Internet header for a spific item\n     * NOTE: https://msdn.microsoft.com/en-us/library/office/aa566013(v=exchg.150).aspx\n     * \n     * @param {string} itemId - The item ID to get\n     * @param {string} headerName - The header to get\n     * @param {string} headerType - The header type (String, Integer)\n     * @param {successCallback} successCallback - Returns the value for the header - function(string) { }\n     * @param {errorCallback} errorCallback - Error handler callback - function(Error) { }\n     * @param {errorCallback} errorCallback - Debug handler returns raw XML - function(String) { }\n     */\n    this.getSpecificHeader = function (itemId, headerName, headerType, successCallback, errorCallback, debugCallback) {\n        /** @type {string} */\n        var soap =\n        '   <m:GetItem>' +\n        '       <m:ItemShape>' +\n        '           <t:BaseShape>IdOnly</t:BaseShape>' +\n        '           <t:AdditionalProperties>' +\n        '               <t:ExtendedFieldURI DistinguishedPropertySetId=\"InternetHeaders\" PropertyName=\"' + headerName + '\" PropertyType=\"' + headerType + '\" />' +\n        '           </t:AdditionalProperties>' +\n        '       </m:ItemShape>' +\n        '       <m:ItemIds>' +\n        '           <t:ItemId Id=\"' + itemId + '\" />' +\n        '       </m:ItemIds>' +\n        '   </m:GetItem>';\n\n        soap = getSoapHeader(soap);\n        // Make the EWS call\n        /** @type {string} */\n        var returnValue = \"\";\n        asyncEws(soap, function (xmlDoc) {\n            try {\n                if (xmlDoc == null) {\n                    successCallback(null);\n                    return;\n                }\n                /** @type {array} */\n                var nodes = getNodes(xmlDoc, \"t:ExtendedProperty\");\n                for(var idx=0;idx < nodes.length; idx++) {\n                    /**@type {XMLNode} */\n                    var value = nodes[idx];\n                    /** @type {string} */\n                    var nodeName = getNodes(value, \"t:ExtendedFieldURI\")[0].getAttribute(\"PropertyName\");\n                    /** @type {string} */\n                    var nodeValue = getNodes(value, \"t:Value\")[0].textContent;\n                    if (nodeName == headerName) {\n                        returnValue = nodeValue;\n                    }\n                }\n                // $.each(nodes, function (index, value) {\n                //     /** @type {string} */\n                //     var nodeName = getNodes(value, \"t:ExtendedFieldURI\")[0].getAttribute(\"PropertyName\");\n                //     /** @type {string} */\n                //     var nodeValue = getNodes(value, \"t:Value\")[0].textContent;\n                //     if (nodeName == headerName) {\n                //         returnValue = nodeValue;\n                //     }\n                // });\n                successCallback(returnValue);\n            } catch (error) {\n                if (errorCallback != null)\n                    errorCallback(error);\n            }\n        }, function (errorDetails) {\n            if (errorCallback != null)\n                errorCallback(errorDetails);\n        }, function (debug) {\n            if (debugCallback != null)\n                debugCallback(debug);\n        });\n    };\n    /**\n     * PUBLIC: Gets Internet headers for a spific item\n     * NOTE: https://msdn.microsoft.com/en-us/library/office/aa566013(v=exchg.150).aspx\n     * \n     * @param {string} itemId - The item ID to get\n     * @param {successCallbackDictionary} successCallback - Callback with a Dictionary(key,value) containing the message headers - function(Dictionary) { }\n     * @param {errorCallback} errorCallback - Error handler callback - function(Error) { }\n     * @param {errorCallback} errorCallback - Debug handler returns raw XML - function(String) { }\n     */\n    this.getEwsHeaders = function (itemId, successCallback, errorCallback, debugCallback) {\n        /** @type {string} */\n        var soap =\n        '   <m:GetItem>' +\n        '       <m:ItemShape>' +\n        '           <t:BaseShape>AllProperties</t:BaseShape>' +\n        '           <t:IncludeMimeContent>true</t:IncludeMimeContent>' +\n        '       </m:ItemShape>' +\n        '       <m:ItemIds>' +\n        '           <t:ItemId Id=\"' + itemId + '\" />' +\n        '       </m:ItemIds>' +\n        '   </m:GetItem>';\n        soap = getSoapHeader(soap);\n        // Make the EWS call\n        /** @type {Dictionary} */\n        var returnArray = new Dictionary();\n        asyncEws(soap, function (xmlDoc) {\n            try {\n                if (xmlDoc == null) {\n                    successCallback(null);\n                    return;\n                }\n                /** @type {array} */\n                var nodes = getNodes(xmlDoc, \"t:InternetMessageHeader\");\n                if(nodes !== null && nodes != undefined) {\n\t\t\t\t\tfor(var i=0;i<nodes.length;i++) {\n\t\t\t\t\t\treturnArray.add(nodes[i].getAttribute(\"HeaderName\"), nodes[i].textContent); \n                    }\n                    successCallback(returnArray);\n                } else {\n                    successCallback(null); // no headers found\n                }\n            } catch (error) {\n                if (errorCallback != null)\n                    errorCallback(error);\n            }\n        }, function (errorDetails) {\n            if (errorCallback != null)\n                errorCallback(errorDetails);\n        }, function (debug) {\n            if (debugCallback != null)\n                debugCallback(debug);\n        });\n    };\n    /**\n     * PUBLIC: Updates a folder property. If the property does not exist, it will be created.\n     * \n     * @param {string} folderId - The ID for the folder\n     * @param {string} propName - The property on the folder to set\n     * @param {string} propValue - The value for the propert\n     * @param {successCallback} successCallback - returns 'succeeeded' is successful - function(String) { }\n     * @param {errorCallback} errorCallback - Error handler callback - function(Error) { }\n     * @param {debugCallback} debugCallback - Debug handler returns raw XML - function(String) { }\n     */\n    this.updateFolderProperty = function (folderId, propName, propValue, successCallback, errorCallback, debugCallback) {\n        /** @type {string} */\n        var soap =\n            '       <m:UpdateFolder>' +\n            '           <m:FolderChanges>' +\n            '               <t:FolderChange>' +\n            '                   <t:FolderId Id=\"' + folderId + '\" />' +\n            '                   <t:Updates>' +\n            '                       <t:SetFolderField>' +\n            '                           <t:ExtendedFieldURI ' +\n            '                              DistinguishedPropertySetId=\"PublicStrings\" ' +\n            '                              PropertyName=\"' + propName + '\" ' +\n            '                              PropertyType=\"String\" />' +\n            '                            <t:Folder>' +\n            '                               <t:ExtendedProperty>' +\n            '                                  <t:ExtendedFieldURI ' +\n            '                                     DistinguishedPropertySetId=\"PublicStrings\" ' +\n            '                                     PropertyName=\"' + propName + '\" ' +\n            '                                     PropertyType=\"String\" />' +\n            '                                 <t:Value>' + propValue + '</t:Value>' +\n            '                              </t:ExtendedProperty>' +\n            '                           </t:Folder>' +\n            '                       </t:SetFolderField>' +\n            '                   </t:Updates>' +\n            '               </t:FolderChange>' +\n            '           </m:FolderChanges>' +\n            '       </m:UpdateFolder>';\n\n        soap = getSoapHeader(soap);\n        // make the EWS call\n        asyncEws(soap, function(data) {\n            if(successCallback != null)\n                successCallback('succeeeded');\n        }, function (error) {\n            if (errorCallback != null)\n                errorCallback(error);\n        }, function (debug) {\n            if (debugCallback != null)\n                debugCallback(debug);\n        });\n    };\n    /**\n     * PUBLIC: Gets a folder property\n     * \n     * @param {string} folderId - The ID for the folder\n     * @param {string} propName - The property to get\n     * @param {successCallback} successCallback - returns the folder property value if successful - function(String) { }\n     * @param {errorCallback} errorCallback - Error handler callback - function(Error) { }\n     * @param {debugCallback} debugCallback - Debug handler returns raw XML - function(String) { }\n     */\n    this.getFolderProperty = function (folderId, propName, successCallback, errorCallback, debugCallback) {\n        /** @type {string} */\n        var soap =\n            '<m:GetFolder>' +\n                '<m:FolderShape>' +\n                    '<t:BaseShape>IdOnly</t:BaseShape>' +\n                    '<t:AdditionalProperties>' +\n                        '<t:ExtendedFieldURI ' +\n                        '   DistinguishedPropertySetId=\"PublicStrings\" ' +\n                        '   PropertyName=\"' + propName + '\" ' +\n                        '   PropertyType=\"String\" />' +\n                    '</t:AdditionalProperties>' +\n                '</m:FolderShape>' +\n                '<m:FolderIds>' +\n                    '<t:FolderId Id=\"' + folderId + '\"/>' +\n                '</m:FolderIds>' +\n            '</m:GetFolder>';\n        soap = getSoapHeader(soap);\n        // make the EWS call\n        asyncEws(soap, function (xmlDoc) {\n            /** @type {array} */\n            var nodes = getNodes(xmlDoc, \"t:Value\");\n            // return the content of the node\n            if (nodes.length > 0) {\n                successCallback(nodes[0].textContent);\n            } else {\n                successCallback(null); // no property found\n            }\n        }, function (error) {\n            if (errorCallback != null)\n                errorCallback(error);\n        }, function (debug) {\n            if (debugCallback != null)\n                debugCallback(debug);\n        });\n    };\n    /**\n     * PUBLIC: Gets the folder id by the given name from the store\n     * \n     * @param {string} folderName - Name of the folder to get the ID for\n     * @param {successCallback} successCallback - returns the folder ID if successful - function(String) { }\n     * @param {errorCallback} errorCallback - Error handler callback - function(Error) { }\n     * @param {debugCallback} debugCallback - Debug handler returns raw XML - function(String) { }\n     */\n    this.getFolderId = function (folderName, successCallback, errorCallback, debugCallback) {\n        /** @type {string} */\n        var soap =\n            '    <m:GetFolder>' +\n            '      <m:FolderShape>' +\n            '        <t:BaseShape>IdOnly</t:BaseShape>' +\n            '      </m:FolderShape>' +\n            '      <m:FolderIds>' +\n            '        <t:DistinguishedFolderId Id=\"' + folderName + '\" />' +\n            '      </m:FolderIds>' +\n            '    </m:GetFolder>';\n        soap = getSoapHeader(soap);\n        // make EWS callback\n        asyncEws(soap, function (xmlDoc) {\n            /** @type {array} */\n            var nodes = getNodes(xmlDoc, \"t:FolderId\");\n            if (nodes.length > 0) {\n                /** @type {string} */\n                var id = nodes[0].getAttribute(\"Id\");\n                successCallback(id);\n            } else {\n                errorCallback(\"Unable to get folder ID\");\n            }\n        }, function (errorDetails) {\n            if (errorCallback != null)\n                errorCallback(errorDetails);\n        }, function (debug) {\n            if (debugCallback != null)\n                debugCallback(debug);\n        });\n    };\n    /**\n     * PUBLIC: Moves an item to the specified folder\n     * \n     * @param {string} itemId - the item to be moved\n     * @param {string} folderId - Name or ID of the folder where the item will be moved\n     * @param {successCallback} successCallback - returns the folder ID if successful - function(String) { }\n     * @param {errorCallback} errorCallback - Error handler callback - function(Error) { }\n     * @param {debugCallback} debugCallback - Debug handler returns raw XML - function(String) { }\n     */\n    this.moveItem = function(itemId, folderId, successCallback, errorCallback, debugCallback) {\n        /** @type {string} */\n        var soap = '<MoveItem xmlns=\"http://schemas.microsoft.com/exchange/services/2006/messages\"' +\n                   '          xmlns:t=\"http://schemas.microsoft.com/exchange/services/2006/types\">' +\n                   '    <ToFolderId>' +\n                   '        <t:DistinguishedFolderId Id=\"' + folderId + '\"/>' +\n                   '    </ToFolderId>' +\n                   '    <ItemIds>' +\n                   '        <t:ItemId Id=\"' + itemId + '\"/>' +\n                   '    </ItemIds>' +\n                   '</MoveItem>';\n        soap = getSoapHeader(soap);\n        // make EWS callback\n        asyncEws(soap, function (data) {\n            if(successCallback != null)\n                successCallback('succeeeded');\n        }, function (errorDetails) {\n            if (errorCallback != null)\n                errorCallback(errorDetails);\n        }, function (debug) {\n            if (debugCallback != null)\n                debugCallback(debug);\n        });\n    };\n    /**\n     * PUBLIC:    Gets all the recipients from the To/CC/BCC lines\n     * NOTE:      Requires the Office.js library to be loaded as it uses its types\n     * \n     * @param {Office.Types.ItemCompose} composeItem - the cast of the Office.context.mailbox.item\n     * @param {getAllRecipientsCallbackDelegate} successCallback - called when completed function(Office.EmailAddressDetails[], Office.EmailAddressDetails[]) { }\n     * @param {errorCallbackDelegate} errorCallback - Error handler callback - function(Error) { }\n     */\n    this.getAllRecipientsAsync = function(composeItem, successCallback, errorCallback) {\n        /** @type {Office.EmailAddressDetails[]} */\n        var users = [];\n        /** @type {Office.EmailAddressDetails[]} */\n        var groups = [];\n        // get the TO line\n        composeItem.to.getAsync(function(toAsyncResult) {\n            if(toAsyncResult.error) {\n                errorCallback(error);\n            } else {\n                /** @type {Office.Recipients} */\n                var recipients = toAsyncResult.value;\n                // if there are results, add them to the return array\n                if(recipients.length > 0) { \n                    recipients.forEach( \n                        /**\n                         * @param {Office.EmailAddressDetails} recip\n                         * @param {Number} index\n                         */\n                        function(recip, index) {\n                            if(recip.recipientType == Office.MailboxEnums.RecipientType.DistributionList) {\n                                /** @type {Boolean} */\n                                var found = false;\n                                for(var i=0; i<groups.length;i++) {\n                                    /** @param {EmailAddressDetails} */\n                                    var item = groups[i];\n                                    if(item.emailAddress == recip.emailAddress) {\n                                        found = true;\n                                        break;\n                                    }\n                                }\n                                if(!found) {\n                                    groups.push(recip);\n                                }\n                            } else {\n                                /** @type {Boolean} */\n                                var found = false;\n                                for(var i=0;i<users.length;i++) {\n                                    /** @param {Office.EmailAddressDetails} */\n                                    var item = users[i];\n                                    if(item.emailAddress == recip.emailAddress) {\n                                        found = true;\n                                        break;\n                                    }\n                                }\n                                if(!found) {\n                                    users.push(recip);\n                                }\n                            }\n                        }\n                    );\n                }\n                // get the CC line\n                composeItem.cc.getAsync(function(ccAsyncResult) {\n                    if(ccAsyncResult.error) {\n                        errorCallback(error);\n                    } else {\n                        /** @type {Office.Recipients} */\n                        var recipients = ccAsyncResult.value;\n                        // if we have results\n                        if(recipients.length > 0) {\n                            recipients.forEach( \n                                /**\n                                 * @param {Office.EmailAddressDetails} recip\n                                 * @param {Number} index\n                                 */\n                                function(recip, index) {\n                                    if(recip.recipientType == Office.MailboxEnums.RecipientType.DistributionList) {\n                                        /** @type {Boolean} */\n                                        var found = false;\n                                        for(var i=0; i<groups.length;i++) {\n                                            /** @param {EmailAddressDetails} */\n                                            var item = groups[i];\n                                            if(item.emailAddress == recip.emailAddress) {\n                                                found = true;\n                                                break;\n                                            }\n                                        }\n                                        if(!found) {\n                                            groups.push(recip);\n                                        }\n                                    } else {\n                                        /** @type {Boolean} */\n                                        var found = false;\n                                        for(var i=0;i<users.length;i++) {\n                                            /** @param {Office.EmailAddressDetails} */\n                                            var item = users[i];\n                                            if(item.emailAddress == recip.emailAddress) {\n                                                found = true;\n                                                break;\n                                            }\n                                        }\n                                        if(!found) {\n                                            users.push(recip);\n                                        }\n                                    }\n                                }\n                            );\n                        } // end-if ccAsyncResult.value.length\n            \n                        // get the BCC line\n                        composeItem.bcc.getAsync(function(bccAsyncResult) {\n                            if(bccAsyncResult.error) {\n                                errorCallback(error);\n                            } else {\n                                /** @type {Office.Recipients} */\n                                var recipients = bccAsyncResult.value;\n                                if(recipients.length > 0) {\n                                    recipients.forEach( \n                                        /**\n                                         * @param {Office.EmailAddressDetails} recip\n                                         * @param {Number} index\n                                         */\n                                        function(recip, index) {\n                                            if(recip.recipientType == Office.MailboxEnums.RecipientType.DistributionList) {\n                                                /** @type {Boolean} */\n                                                var found = false;\n                                                for(var i=0; i<groups.length;i++) {\n                                                    /** @param {EmailAddressDetails} */\n                                                    var item = groups[i];\n                                                    if(item.emailAddress == recip.emailAddress) {\n                                                        found = true;\n                                                        break;\n                                                    }\n                                                }\n                                                if(!found) {\n                                                    groups.push(recip);\n                                                }\n                                            } else {\n                                                /** @type {Boolean} */\n                                                var found = false;\n                                                for(var i=0;i<users.length;i++) {\n                                                    /** @param {Office.EmailAddressDetails} */\n                                                    var item = users[i];\n                                                    if(item.emailAddress == recip.emailAddress) {\n                                                        found = true;\n                                                        break;\n                                                    }\n                                                }\n                                                if(!found) {\n                                                    users.push(recip);\n                                                }\n                                            }\n                                        }\n                                    );\n                                    successCallback(users, groups);\n                                } else {\n                                    successCallback(users, groups);\n                                } // end-if(bccAsyncResult.value.length > 0)\n                            } // end-if(bccAsyncResult.error)\n                        }); //composeItem.bcc.getAsync\n                    } // end-if(ccAsyncResult.error)\n                }); // composeItem.cc.getAsync\n            } // end-if(toAsyncResult.error)\n        }); // to.getAsync\n    };\n/***********************************************************************************************\n ***********************************************************************************************\n ***********************************************************************************************\n                          ****  ****  ***** *   *  ***  ***** *****  ***                            \n                          *   * *   *   *   *   * *   *   *   *     *   *                           \n                          ****  ****    *   *   * *****   *   ***     *                             \n                          *     *   *   *    * *  *   *   *   *     *   *                           \n                          *     *   * *****   *   *   *   *   *****  ***                            \n***********************************************************************************************\n***********************************************************************************************\n***********************************************************************************************/\n    /**\n     * PRIVATE:         Expands a group, if other groups found in the group\n     *                  recursively calls itself until all groups are split\n     */\n    function splitGroupsRecursivelyAsync() {\n        // if there are no more groups found, or we have recursively\n        // found more than 10 levels of groups, then we stop\n        if(groups.length == 0 || groupCount > 100) { \n            // if no groups stop\n            splitGroupSuccessCallback(users); \n        } else {\n            /** @type {string} */\n            var group = groups.pop();\n            processedGroups.push(group);\n            // call expandGroup to get users\n            easyEws.expandGroup(group, function(groupResult) {\n                for(var index=0; index < groupResult.length; index++) {\n                    var result = groupResult[index];\n                    if(result.MailboxType() == \"PublicDL\" || \n                        result.MailboxType() == \"PrivateDL\") {\n                        // add the group to the list of results as\n                        // long as it does not already contain a group\n                        // we have processed or a group that is on the\n                        // stack to be processed\n                        if(processedGroups.indexOf(result.Address()) < 0 && \n                            groups.indexOf(result.Address()) < 0) {\n                            groupCount++;\n                            groups.push(result.Address());\n                        }\n                    } else {\n                        // add the user to the list as long as they have\n                        // not already been included already. This way\n                        // we have a list of unique results.\n                        /** @type {boolean} */\n                        var found = false;\n                        for(var i=0;i < users.length; i++) {\n                            /** @type {MailboxUser} */\n                            var item = users[i];\n                            if(item.Address() == result.Address()) {\n                                found = true;\n                                break;\n                            }\n                        }\n                        if(found == false) {\n                            users.push(result);\n                        }\n                    }\n                } // groupUsers.forEach\n                splitGroupsRecursivelyAsync(); // recursive\n            }, function(error) {\n                splitGroupErrorCallback(error);\n            }, function(debug) {\n                splitGroupDebugCallback(debug);\n            }); // easyEws.expandGroup\n        } // end-if\n    };\n    /**\n     * PRIVATE: creates a SOAP EWS wrapper\n     * \n     * @param {string} request The XML body of the soap message\n     */\n    function getSoapHeader(request) {\n        /** @type {string} */\n        var result =\n            '<?xml version=\"1.0\" encoding=\"utf-8\"?>' +\n            '<soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"' +\n            '               xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"' +\n            '               xmlns:m=\"http://schemas.microsoft.com/exchange/services/2006/messages\"' +\n            '               xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"' +\n            '               xmlns:t=\"http://schemas.microsoft.com/exchange/services/2006/types\">' +\n            '   <soap:Header>' +\n            '       <RequestServerVersion Version=\"Exchange2013\" xmlns=\"http://schemas.microsoft.com/exchange/services/2006/types\" soap:mustUnderstand=\"0\" />' +\n            '   </soap:Header>' +\n            '   <soap:Body>' + request + '</soap:Body>' +\n            '</soap:Envelope>';\n        return result;\n    };\n\n    /**\n     * PRIVATE: Makes an EWS callback with promise\n     * \n     * @param {string} soap - XML Soap message\n     * @param {function({DOMDocument})} successCallback - Success callback - function(DOMDocument) { }\n     * @param {function({Object})} errorCallback - Error handler callback - function(Error) { }\n     * @param {function({string})} debugCallback - Debug callback - function(String) { }\n     */\n    function asyncEws(soap, successCallback, errorCallback, debugCallback) {\n        Office.context.mailbox.makeEwsRequestAsync(soap, function (ewsResult) {\n            if (ewsResult.status == \"succeeded\") {\n                /** @type {DOMParser} */\n                var parser = new DOMParser();\n                /**@type {XMLDocument} */\n                var xmlDoc = parser.parseFromString(ewsResult.value, \"text/xml\");\n                //var xmlDoc = $.parseXML(ewsResult.value);                   \n                successCallback(xmlDoc);\n\n                // provide a detailed debug with the initial soap, fully formed\n                // and the response from the server\n                debugCallback(\"STATUS: \" + ewsResult.status + \"\\n\" +\n                                \"---- START SOAP ----\\n\" + soap + \"\\n---- END SOAP ----\\n\" +\n                                \"---- START RESPONSE ----\\n\" + ewsResult.value + \"---- END RESPONSE ----\"); // return raw result\n            } else {\n                if (errorCallback != null) {\n                    errorCallback(ewsResult.error);\n                    debugCallback(\"STATUS: \" + ewsResult.status + \"\\n\" +\n                                    \"ERROR: \" + ewsResult.error + \"\\n\" +\n                                    \"---- START SOAP ----\\n\" + soap + \"\\n---- END SOAP ----\\n\" +\n                                    \"---- START RESPONSE ----\\n\" + ewsResult.value + \"---- END RESPONSE ----\"); // return raw result\n                }\n            }\n        }); \n    };\n    /** \n     * PRIVATE: This function returns an element node list based on the name\n     *           provided (using the Namespace, such as t:Item). It will look\n     *           for t:Item and return all nodes, but it not, it will seach\n     *           without the namespace \"Item\"\n     *NOTE: This is done because there is a difference in calling EWS functions\n        *      from the browser in OWA and the full client Outlook\n        * @param {XMLNode} node - The parent node\n        * @param {string} elementNameWithNS - The element tagname to get with namespace\n        * @return {XMLNode} - The node found\n    */\n    function getNodes(node, elementNameWithNS) {\n        /** @type {string} */\n        var elementWithoutNS = elementNameWithNS.substring(elementNameWithNS.indexOf(\":\") + 1);\n        /** @type {array} */\n        var retVal = node.getElementsByTagName(elementNameWithNS);\n        if (retVal == null || retVal.length == 0) {\n            retVal = node.getElementsByTagName(elementWithoutNS);\n        }\n        return retVal;\n    };\n};\n\n/***********************************************************************************************\n ***********************************************************************************************\n ***********************************************************************************************\n                             *   * ***** *     ****  ***** ****   ***                               \n                             *   * *     *     *   * *     *   * *   *                              \n                             ***** ***   *     ****  ***   ****    *                                \n                             *   * *     *     *     *     *   * *   *                              \n                             *   * ***** ***** *     ***** *   *  ***                                                            \n***********************************************************************************************\n***********************************************************************************************\n***********************************************************************************************/\n/* HELPER FUNCTIONS AND CLASSES */\n\n/**\n * A simple attachment object containing only the name and mime data\n * @param {string} name - the name of the attachment \n * @param {string} mime - the mime data (base64 string)\n * @param {string} type - this should be \"file\" (for a file attachment) or \"item\" (for a mailitem)\n */\nfunction SimpleAttachmentObject (name, mime, type) {\n    this.name = name || \"\";\n    this.mime = mime || \"\";\n    this.type = type || \"\";\n};\n\n/**\n * An IE11 based helper object for the sendMail Function\n * @param {string} subject - the subject of the message\n * @param {string} body - The body of the message to be sent\n * @param {string} bodytype - this should be \"html\" or \"text\", default is text\n * @param {string[]} recipients[] - Email address(es) of the recipient(s) as an Array of strings eg [\"a@b.com\", \"c@d.com\"]\n * @param {simpleAttachmentObject[]} attachments - array of objects of form {name: string, mime: BASE64 string} to be attached. Pass [{}] if no attachments.\n * @param {string} folderid - distinguished folder id of folder to put the sent item in \n * @param {successCallback} successCallback - Callback with 'success' if compelted successfully - function(string) { }\n * @param {errorCallback} errorCallback - Error handler callback - function(string) { }\n * @param {debugCallback} debugCallback - Debug handler returns raw XML - function(string) { }\n */\nfunction SendMailFunctionObject(subject, body, bodytype, recipients, attachments, folderid, successCallback, errorCallback, debugCallback) {\n    this.subject = subject || \"\";\n    this.body = body || \"\";\n    this.bodytype = bodytype || \"text\";\n    this.recipients = (recipients !== undefined && recipients !== null) ? recipients : [\"\"];\n    this.attachments = (attachments !== undefined && attachments !== null) ? attachments : [new SimpleAttachmentObject(\"\",\"\")];\n    this.folderid = (folderid !== undefined && folderid !== null && folderid !==\"\" ) ? folderid : \"sentitems\";\n    this.successCallback = successCallback || {};\n    this.errorCallback = errorCallback || {};\n    this.debugCallback = debugCallback || {};\n};\n\n/**\n * @typedef {Object} MailItem\n * @property {string} MimeContent Returns the MimeContent of the message\n * @property {string} CharacterSet Returns the mime content character set\n * @property {string} Subject Returns the subject of the message\n * @param {XMLDocument} value Sets the value of a new MailItem\n */\nfunction MailItem(value) {\n    this.value = value || {};\n\n    /**\n     * Returns the MimeContent of the message\n     * @returns {string} Base64 string\n     */\n    this.MimeContent = function () {\n        return this.value.getElementsByTagName(\"t:MimeContent\")[0].textContent;\n    };\n\n    /**\n     * Returns the mime content character set\n     * @returns {string} Character set value\n     */\n    this.CharacterSet = function () {\n        return this.value.getElementsByTagName(\"t:MimeContent\")[0].getAttribute(\"CharacterSet\");\n    };\n\n    /**\n     * Returns the subject of the message\n     * @returns {string} Subject line\n     */\n    this.Subject = function () {\n        return this.value.getElementsByTagName(\"t:Subject\")[0].textContent;\n    };\n\n    /** Returns the body of the message \n     * @returns {string} Body text\n    */\n    this.Body = function () {\n        return this.value.getElementsByTagName(\"t:Body\")[0].textContent;\n    }\n}\n\n/**\n * Mailbox user wrapper\n *      <t:Mailbox>\n *          <t:Name>username</t:Nname>\n *          <t:EmailAddress>user@there.com</t:EmailAddress>\n *          <t:RoutingType>SMTP</t:RoutingType>\n *          <t:MailboxType>Mailbox / PublicDL</t:MailboxType>\n *      </t:Mailbox>\n * @typedef {Object} MailboxUser\n * @property {string} Name Returns the name of the item\n * @property {string} Email Returns the email address of the item\n * @property {string} RoutingType Returns the type of address of the item\n * @property {string} MailboxType Returns is the item is a mailbox user or a PublicDL\n * @param {XMLDocument} value XML string from EWS request\n */\nfunction MailboxUser(value) {\n    this.value = value || {};\n    /**\n     * Returns the name of the item\n     * @returns {string} The user name\n     */\n    this.Name = function () {\n        return this.value.getElementsByTagName(\"t:Name\")[0].textContent;\n    };\n    /**\n     * Returns the email address of the item\n     * @returns {string} email\n     */\n    this.Address = function () {\n        return this.value.getElementsByTagName(\"t:EmailAddress\")[0].textContent;\n    };\n    /**\n     * Returns the routing type for this mailbox\n     * SEE: https://msdn.microsoft.com/en-us/library/office/aa563474(v=exchg.150).aspx\n     * @returns {string} type ActingAs | Mailbox | RoomList\n     */\n    this.RoutingType = function () {\n        return this.value.getElementsByTagName(\"t:RoutingType\")[0].textContent;\n    };\n    /**\n     * Returns the mailbox type such as Mailbox, PublicDL, PrivateDL, Contact, etc.\n     * SEE: https://msdn.microsoft.com/en-us/library/office/aa563493(v=exchg.150).aspx\n     * @returns {string} Mailbox | PublicDL | PrivateDL | Contact | PublicFolder | Unknown | OneOff | GroupMailbox\n     */\n    this.MailboxType = function () {\n        return this.value.getElementsByTagName(\"t:MailboxType\")[0].textContent;\n    };\n}\n\n/**\n * Dictionary Object Class\n * Helps to work with items in a dictionary with key value pairs\n * \n * @typedef {Object} Dictionary\n * @property {function(Object, function())} forEach Loops through each item in the Dictionary\n * @property {function(string)} lookup Returns the value for the specified key\n * @property {function(string, Object)} add Adds a new item to the Dictionary collection\n * @property {boolean} containsKey True if key exists in collection\n * @property {Number} length Returns the length of the array, or number of items\n * @param {Object[]} values Array of values\n */\nfunction Dictionary(values) {\n    this.values = values || {};\n\n    /**\n     * INTERNAL: Loops through each item in the Dictionary\n     * @param {Object} object \n     * @param {function(Object, Object)} action \n     */\n    var forEachIn = function (object, action) {\n        for (var property in object) {\n            if (Object.prototype.hasOwnProperty.call(object, property))\n                action(property, object[property]);\n        }\n    };\n\n    /**\n     * Returns true if it contains the specified key\n     * @param {string} key \n     */\n    this.containsKey = function (key) {\n        return Object.prototype.hasOwnProperty.call(this.values, key) &&\n          Object.prototype.propertyIsEnumerable.call(this.values, key);\n    };\n\n    /**\n     * For each function for the Dictionary\n     * @param {function(Object,Object)}\n     */\n    this.forEach = function (action) {\n        forEachIn(this.values, action);\n    };\n\n    /**\n     * Returns the value for the specified key\n     * @param {Object} key The value found\n     */\n    this.lookup = function (key) {\n        return this.values[key];\n    };\n\n    /**\n     * Adds a new item to the Dictionary collection\n     * @param {string} key The key name\n     * @param {Object} value The value\n     */\n    this.add = function (key, value) {\n        this.values[key] = value;\n    };\n\n    /**\n     * Returns the length of the array, or number of items\n     * @returns {Number} The number of items in the array\n     */\n    this.length = function () {\n        /** @type {number} */\n        var len = 0;\n        forEachIn(this.values, function () { len++ });\n        return len;\n    };\n};\n\n/**\n * Helper function to encode HTML in the string of text. Will convert\n * <b>Hello World</b> to\n * &lt;b&gt;Hello World&lt;/b&gt;\n * @param {string} html - the string to escape\n */\nfunction escapeHTML(html) {\n    var fn=function(tag) {\n        var charsToReplace = {\n            '&': '&amp;',\n            '<': '&lt;',\n            '>': '&gt;',\n            '\"': '&#34;'\n        };\n        return charsToReplace[tag] || tag;\n    }\n    return html.replace(/[&<>\"]/g, fn);\n}\n/***********************************************************************************************\n ***********************************************************************************************\n ***********************************************************************************************\n              *****  ***  ****   ***   ***        ***** *   * ***** ****   ***   ***                \n                 *  *   * *   * *   * *   *       *      * *    *   *   * *   * *   *               \n                 *    *   *   * *   * *           ***     *     *   ****  *****   *                 \n              *  *  *   * *   * *   * *   *       *      * *    *   *   * *   * *   *               \n               **    ***  ****   ***   ***        ***** *   *   *   *   * *   *  ***                                                                         \n***********************************************************************************************\n***********************************************************************************************\n***********************************************************************************************/\n/**\n * This is the sucess callback\n * @callback successCallback\n * @param {string} result\n * @returns {void}\n */\nvar successCallback = function(result) { };\n/**\n * This is the sucess callback\n * @callback successCallbackMailItem\n * @param {MailItem} result\n * @returns {void}\n */\nvar successCallbackMailItem = function(result) { };\n/**\n * This is the sucess callback\n * @callback successCallbackArray\n * @param {string[]} result\n * @returns {void}\n */\nvar successCallbackArray = function(result) { };\n/**\n * This is the success callback\n * @callback successCallbackMailboxUserArray\n * @param {MailboxUser[]} result\n * @returns {void}\n */\nvar successCallbackMailboxUserArray = function(result) { };\n/**\n * This is the sucess callback\n * @callback successCallbackDictionary\n * @param {Dictionary} result\n * @returns {void}\n */\nvar successCallbackDictionary = function(result) { };\n/**\n * This is the error callback\n * @callback errorCallback\n * @param {string} error\n * @returns {void}\n */\nvar errorCallback = function(error) { };\n/**\n * This is the debug callback\n * @callback debugCallback\n * @param {string} debug\n * @returns {void}\n */\nvar debugCallback = function(debug) { };\n/**\n * Calback with users and groups\n * @callback getAllRecipientsCallbackDelegate\n * @param {Office.EmailAddressDetails[]} users \n * @param {Office.EmailAddressDetails[]} groups \n */\nvar getAllRecipientsCallbackDelegate = function(users, groups) { }\n"],"names":["easyEws","splitGroupSuccessCallback","splitGroupErrorCallback","splitGroupDebugCallback","groups","processedGroups","users","groupCount","ResolveNamesType","name","emailAddress","routingType","mailboxType","this","routiingType","splitGroupsRecursivelyAsync","length","group","pop","push","expandGroup","groupResult","index","result","MailboxType","indexOf","Address","found","i","error","debug","getSoapHeader","request","asyncEws","soap","successCallback","errorCallback","debugCallback","Office","context","mailbox","makeEwsRequestAsync","ewsResult","status","xmlDoc","DOMParser","parseFromString","value","getNodes","node","elementNameWithNS","elementWithoutNS","substring","retVal","getElementsByTagName","getParentId","childId","getItemXmlDoc","internetMessageId","textContent","replace","findItemXmlDoc","parentId","attributes","resolveRecipient","recipient","message","innerHTML","returnArray","nodes","idx","obj","errorDetails","sendMailItem","p","fn","subject","bodytype","toLowerCase","body","tag","recipients","undefined","attachments","SimpleAttachmentObject","folderid","xmlRecipients","forEach","address","xmlAttachments","attachment","mime","type","elem","sendPlainTextEmailWithAttachment","to","attachmentName","attachmentMime","SendMailFunctionObject","getMailItemMimeContent","mailItemId","content","updateEwsHeader","headerName","headerValue","isMeeting","firstLine","getFolderItemIds","folderId","opts","maxEntries","queryString","getAttribute","getMailItem","itemId","item","MailItem","splitGroupsAsync","groupList","extendedProps","MailboxUser","findConversationItems","conversationId","Error","getSpecificHeader","headerType","returnValue","nodeName","nodeValue","getEwsHeaders","Dictionary","add","updateFolderProperty","propName","propValue","data","getFolderProperty","getFolderId","folderName","id","moveItem","getAllRecipientsAsync","composeItem","getAsync","toAsyncResult","recip","recipientType","MailboxEnums","RecipientType","DistributionList","cc","ccAsyncResult","bcc","bccAsyncResult","MimeContent","CharacterSet","Subject","Body","Name","RoutingType","values","forEachIn","object","action","property","Object","prototype","hasOwnProperty","call","containsKey","key","propertyIsEnumerable","lookup","len"],"sourceRoot":""}